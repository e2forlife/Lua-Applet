-- LOG:
-- 1.1.5 : Updated with new progress bar module.
------------------------------------------------------------------------------
-- make sure that all of the used extensions are present
if ansi == nil then
    print("\x1b[34m[\x1b[91mERROR\x1b[34m]\x1b[37m: Remapping \x1b[96mansi()\x1b[37m to io.write().\n\x1b[92mPlease use eXtended Lua (\x1b[93mxLua\x1b[92m)\x1b[37m\n")  
    function ansi(s)  io.write(s) end
end
-- ---------------------------------------------------------------------------
local sep  = package.config:sub(1,1) -- extract the separator
package.path = ("..{SEP}modules{SEP}?.lua;.{SEP}modules{SEP}?.lua;"):gsub("{SEP}",sep) .. package.path
------------------------------------------------------------------------------
local app = require "app"
local progress = require "progress2"
------------------------------------------------------------------------------
local compile = app.new(false)  -- create the application framework object
------------------------------------------------------------------------------
compile.name = "Lcompile"
compile.brief = "Compile Lua source to binary chunk and/or C application file."
compile.version = "2.3.0"  -- requires xLua w/ "ansi()" function
compile.detail = [[
Lcompile is a Lua compiler that was written in Lua!  It allows for the compilation
of Lua source files into compiled binary modules and/or a C source file that can
be included in a standalone executable project.

   {c4}[{c10}USAGE{c4}]{c7}: {c15}Lcompile {c6}--quiet --def={c4}<{c5}#define{c4}> {c6}--app={c4}<{c5}object{c4}> {c6}--obj --ofile={c4}<{c5}output{c4}> {c11}...
{c7}------------------------------------------------------------------------------
   {c15}--quiet    {c7}: {c2}surppress messages on the console.
   {c15}--ofile=   {c7}: {c2}define the target C-source file.
   {c15}--def=     {c7}: {c2}Include #define flags around generate source
   {c15}--app=     {c7}: {c2}module name of the application
   {c15}--obj=     {c7}: {c2}generate binary object modules for each source input
   {c15}--legacy   {c7}: {c2}use Legacy file generation mode (this is SLOW)
   {c15}--fast     {c7}: {c2}Enable "fast" mode output; no newlines in data.
   {c15}--force    {c7}: {c2}Force compile source even when object files exist.
   {c15}...        {c7}: {c2}the input lua file to compile to binary.
{c7}------------------------------------------------------------------------------
Lcompile will load the input specified Lua files and compile them to a
binary chunk creating a source file containing a loader and an execution
function stubs for running the code.  Code that is "require"'d by the main
application is compiled and stored in the output C-source file.  

A note on object generation:
This version of lcompile enable the pre-compilation of object files into
*.chunk.c output objects.  You can use the --obj= option to set the object
directory path, or just use the --obj to specify the current directory as
the object path.

Note that the order of the input files on the command line are important
for the generated C-source, as they are loaded in the order that they are
specified.  So, make sure that interdependencies are handled by placing
files that require other files LAST in the input file list.

To use this tool, pass the main source to the compiler as an input file
along with the source of all the required modules (unless you want to
package the Lua with the exe).  All dependencies that are "required" are
loaded and included in the output binary chunk when specified in the build
list, otherwise they will be required from Lua and the source or Lua chunk
must be accessible on the package.path.

   Example:
   Lcompile --oflie=lcomp.c --def=LUA_COMPILE --app=compiler --obj compiler.lua ../app.lua
   Lcompile myfile.lua

------------------------------------------------------------------------------
]]
------------------------------------------------------------------------------
compile.header = [[
/**
 * ===========================================================================
 * Autogenerated application source
 * ---------------------------------------------------------------------------
 * This file was autogenerated from compiled Lua source using the Lcompile
 * Lua to C compiler.  The ouput file is intended to be compiled alongside
 * the application run-time environment that contains some extensions to
 * the base Lua language.
 * ===========================================================================
 * Built with ${VER}
 * ---------------------------------------------------------------------------
 */
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
   
#include <stdbool.h>
#include <stdint.h>
#include <signal.h>
/* Internal Handlers ====================================================== */
static lua_State *app_l = NULL;  /* Pointer to the Lua State for the Applet */
#define APPLET_NAME "${APPLET_NAME}" /* define the name of the applet command */
/* ------------------------------------------------------------------------ */
/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int app_report (lua_State *L, int status)
{
    if (status != LUA_OK)
    {
        const char *msg = lua_tostring(L, -1);
        lua_writestringerror("%s: ", APPLET_NAME);
        lua_writestringerror("%s\n", msg);
        lua_pop(L, 1);  /* remove message */
    }
    return status;
}
/* Message handler used to run all chunks --------------------------------- */
static int app_msghandler (lua_State *L)
{
    const char *msg = lua_tostring(L, 1);
    if (msg == NULL)
    {  /* is error object not a string? */
        if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
            lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
        {
            return 1;  /* that is the message */
        }
        else
        {
            msg = lua_pushfstring(L, "(error object is a %s value)",
                luaL_typename(L, 1));
        }
    }
    luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
    return 1;  /* return the traceback */
}
/* Hook set by signal function to stop the interpreter -------------------- */
static void app_stop (lua_State *L, lua_Debug *ar)
{
    (void)ar;  /* unused arg. */
    lua_sethook(L, NULL, 0, 0);  /* reset hook */
    luaL_error(L, "interrupted!");
}
/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/
static void app_action (int i)
{
    int flag = LUA_MASKCALL | LUA_MASKRET | LUA_MASKLINE | LUA_MASKCOUNT;
    signal(i, SIG_DFL); /* if another SIGINT happens, terminate process */
    lua_sethook(app_l, app_stop, flag, 1);
}
]]
------------------------------------------------------------------------------
compile.module_code = [[
/* MODULE : ${MODNAME} */
/* ------------------------------------------------------------------------ */
static const uint8_t ${MODNAME}_buffer[] = {
${BINDATA}
};
/* ------------------------------------------------------------------------ */   
]]
compile.require_template = [[
/* Required module ======================================================== */
${CODE_DATA}
LUALIB_API int luaopen_${MODNAME}( lua_State *L )
{
    // load the chunk in bin mode and put it on the stack
    luaL_loadbufferx(L, (const char*)&${MODNAME}_buffer[0], ${SIZE}, "${MODNAME}", "b");
    /* After loading the binary chunk, we are left with a function on the stack
     * that represents the compiled code.  This pcall runs the code loaded to
     * (in the case of a require) create the stack, otherwise, only the loaded
     * code function would be stored in the `package.loaded` table.
     */
    lua_pcall(L,0,1,0); // one argument is returned... the module
    return 1;
}
/* ======================================================================== */
]]
------------------------------------------------------------------------------
compile.require_code = "   luaL_requiref(L, \"${MODNAME}\", luaopen_${MODNAME}, 1);\n   lua_pop(L,1);\n"
------------------------------------------------------------------------------
compile.template = [[
/* ------------------------------------------------------------------------ */

/* ------------------------------------------------------------------------ */
int app_run(lua_State *L)
{
    /* Required modules --------------------------------------------------- */
${REQDATA}
    lua_Integer top = lua_gettop(L);
    /* Run main application ----------------------------------------------- */
    // this call loads and runs the target application module
    luaL_loadbufferx(L, (const char*)&${NAME}_buffer[0], ${APPSIZE}, "${NAME}", "b");

    int status;
    int base = lua_gettop(L);  /* function index */
    lua_pushcfunction(L, app_msghandler);  /* push message handler */
    lua_insert(L, base);  /* put it under function and args */
    app_l = L;  /* to be available to 'laction' */
    signal(SIGINT, app_action);  /* set C-signal handler */
    status = lua_pcall(L, 0, 1, base);
    signal(SIGINT, SIG_DFL); /* reset C-signal handler */
    lua_remove(L, base);  /* remove message handler from the stack */
    return app_report(L, status);
}
/* ------------------------------------------------------------------------ */
/* END OF FILE ============================================================ */
]]
------------------------------------------------------------------------------
compile.object_template = [[
return {
    code_data = {$CODE_DATA},
    modname = ${MODNAME},
    data_length = ${SIZE}
}
]]
-- Helper Functions ==========================================================
------------------------------------------------------------------------------
--- Check if a file or directory exists in this path
local function exists(file)
   local ok, err, code = os.rename(file, file)
   if not ok then
      if code == 13 then
         -- Permission denied, but it exists
         return true
      end
   end
   return ok, err
end
------------------------------------------------------------------------------
local function object_file(path, modname)
    local source_file = ""
    local header_file = ""
    if type(path) == "string" then
        obj = string.format("%s%s%s.chunk.c",path, sep, modname)
    else
        obj = string.format("%s.chunk.c",modname)
    end
    return obj
end
-- Applet Code ===============================================================
------------------------------------------------------------------------------
function compile:get_modname( fname )
    -- split the file path name to get the file name and the pat seperate.
    local path = fname:split("[^/\\]+")
    local file = path[#path]   -- filename (sans path) is the last entry in the table
    local modname = file:split("[^%.]+") -- seperate the file name from the extenstion
    local ext = modname[#modname] -- grab the extension of the file loaded
    if #modname > 1 then table.remove(modname,#modname) end
    -- convert the table back to a string using underscores
    -- as the seperator.
    modname = table.concat(modname,"_")
    modname = modname:gsub("[%-%s]+","_") -- replace dash with underscore

    return modname, file, ext
end
------------------------------------------------------------------------------
function compile:compile_source( fname )
    -- load lua source and compile to a chunk.
    local chunk = string.dump( loadfile(fname,"bt"), true )
    -- then grab the filename and module name from the file.
    local modname, file = self:get_modname(fname)
    local app = "    "
   
    if not self.opts.legacy then
        -- new compile method for compiling lines to C
        local byte = 0
        if not self.opts.fast then
            local pb = progress.new(50,#chunk)
            pb.step = 12
            ansi("{hide}") -- turn off cursor
            while byte < #chunk do
                ansi( pb:next() .. "  {c7}Compiling file {c14}"..file.."{c7}\r")
                local ss = chunk:sub(byte+1,byte+12)
                if #ss > 0 then
                    app = app .. ss:gsub(".",
                        function(c)
                            return string.format("0x%02X, ",c:byte())
                        end
                        )
                    byte = byte + 12
                    app = app .. "\n    "
                end
            end
        else
            -- generate "fast" mode data output (all on one line)
            -- that will just burst generate the output with no
            -- newlines.  this is generally most useful for huge
            -- lua source that takes a while to compile.
            app = app .. chunk:gsub(".",
                function(c)
                    return string.format("0x%02X, ",c:byte())
                end
            )
        end
    else
        -- Legacy method replaced with gsub method
        local byte = 0
        local pb = progress.new(0,#chunk)
        pb.char = {"{c7}=", "{c4}\\", "{c12}|", "{c14}/", "{c10}#" }
        pb.plain = self.plain -- propogate plain mode
        for _,v in ipairs({chunk:byte(1,#chunk)} ) do
            pb:next()  -- update progressbar position
            pb:render() -- draw it onscreen
            ansi("  compiling {c14}"..file)
            byte = byte + 1
            if byte > 12 then
                byte = 1
                app = app .. "\n   "
            end
            app = app .. string.format("0x%02X, ",v)
        end
    end
    ansi("{c7;b0;show}\n  Done\n")

    -- return the base filename, the module name, and nthe copiled chunk data
    return modname, app, #chunk
end
------------------------------------------------------------------------------
function compile:save_object( modname, code, codesize)
    -- This function will write compiled source data to object files.  Object
    -- data inlcude the compiled code block, bytes in the code block and the
    -- module name.  The data is organized with the header of the file containing
    -- the meta data and the remainder containing the built code block
    local filename = object_file( self.opts.obj, modname)
    local fil = io.open(filename,"w+")
    if fil ~= nil then
        fil:write(modname.."\n")
        fil:write(tostring(codesize).."\n")
        fil:write(code)
        fil:close()
    else
        self:message("error","there wasn an error opening object file {c9}%s{c7} for writing.", filename)
    end
end
------------------------------------------------------------------------------
function compile:load_object( modname )
    local code = ""
    local codesize = 0
    local filename = object_file( self.opts.obj, modname)
    local fil = io.open(filename,"r")
    if fil ~= nil then
        local name = fil:read("l")
        if name == modname then
            codesize = tonumber(fil:read("l"))
            code = fil:read("a")
        else
            self:message("error","When reading object for module {c11}%s{c7}, {c9}%s{c7} was found!",modname, name)
        end
        fil:close()
    else
        self:message("error","there wasn an error opening object file {c9}%s{c7} for writing.", filename)
    end

    return code,codesize
end
------------------------------------------------------------------------------
-- load a module and render a text buffer of the data as HEX strings for loading
-- This function return the module name, the code template and the length of the
-- code buffer.
function compile:compile( file )
    local mod,fname,ftype = self:get_modname(file)
    local tplt = ""
    local data = ""
    local size = 0

    -- when there was a precompiled chunk passed as the file, the compiler will just load
    -- the chunk into the buffer and return the chunk data.
    if ftype:lower() ~= "lua" then
        -- load a pre-compiled object
        mod = mod:gsub("_chunk","") -- remove chunk portion of name
        self:message("info","Loading precompiled module {c6}%s{c7}.",mod)
        tplt,size = self:load_object(mod)
    else
        if exists(file) then
            local obj_name = object_file(self.opts.obj,mod)
            if not self.opts.force and exists(obj_name) then
                tplt,size = self:load_object(mod)
            else
                mod,data,size = self:compile_source(file)
                -- requirement was processed. add to the output file
                -- and build the require list
                tplt = self.module_code:gsub("${MODNAME}", mod)
                tplt = tplt:gsub("${BINDATA}", data)
            end
        else
            self:message("error","File {c9}%s{c7} is missing or invalid.",file)
        end
    end
    return mod, tplt, size
end
-- Framework callbacks =======================================================
------------------------------------------------------------------------------
function compile:init()
    -- tool initialization and setting of default options and switches
end
------------------------------------------------------------------------------
function compile:main( ifile, ofile )

    ansi(self.name .. " Version "..self.version.."\n")
    ansi("(C) {c15}2021-2023 {c34}E{c35}2{c214}For{c34}Life{c7}.com, CC-BY-SA-NC v4.0\n\n")

    local app_mod = self.opts.ofile and self:get_modname(self.opts.ofile) or "default_app"
    local applet_name = self.opts.name or app_mod
    local applet_size = 0

    -- assign the default application
    if not self.opts.app and self.opts.ofile then
        self:message("warn","Applet module was unspecified, setting application module to {c11}%s{c7}.",app_mod)
        self.opts.app = app_mod
    end

    self.opts.verbose = not self.opts.quiet
    self.plain = self.opts.plain  -- setup plain mode

    if not ifile or #ifile == 0 then
        self.opts.verbose = true
        self:message("error","There are no input files!")
        io.write("\n\n")
        self:help()
        return false
    end

    local outfile = self.opts.ofile or "stdout"
    -- Compile the source
    -- This loads the chunks for each file, dumps the binary data and
    -- generates the loader for the module.  the loader data is stored
    -- in a big array of module names and required data
    local source_data = {}
    local requires = ""
    for _,source in ipairs(ifile) do
        local modname, code, data_length = self:compile(source)
        if modname == nil then 
            self:message("error","Errors detected during compilation.")
            return false, "compile error"
        end
        if modname == self.opts.app then
            -- when the loaded module is module identified as the applet
            -- load the code buffer into the source data, and retain the
            -- data length as the size of the applet (needed for later loading)
            source_data[modname] = code
            applet_size = data_length
        else
            -- otherwises, this is a require module that is being loaded.
            -- append the execution code for the loader to read in the
            -- require module and return the results from the module that
            -- was loaded.
            local require_template = self.require_template:gsub("${CODE_DATA}",code)
            require_template = require_template:gsub("${MODNAME}",modname)
            require_template = require_template:gsub("${SIZE}",data_length)
            source_data[modname] = require_template
            -- when the compiler is outputting object data as compiles are executed,
            -- Create the output object files.
            if self.opts.obj then
                self:save_object(modname,code,data_length)
            end
        end

        if modname ~= self.opts.app then
            -- generate a require line for the module
            requires = requires .. self.require_code:gsub("${MODNAME}",modname)
        end
    end

    -- generate output data file
    if self.opts.ofile then
        if self.opts.def then 
            self:message("Info","Adding {c5}#ifdef{c7} conditionals for {c11}"..self.opts.def)
            ofile:write("#ifdef "..self.opts.def.."\n")
        end
        self:message("Info","Writing output file {c15}%s",outfile)
        local hdr = self.header:gsub("${VER}", self.name .. " v"..self.version.."  ( ".._VERSION.." )")
        hdr = hdr:gsub("${APPLET_NAME}", applet_name)
        ofile:write(hdr)
        -- write the module loaders
        for name,code in pairs(source_data) do
            self:message("Info","Writing module {c11}%s",name)
            ofile:write(code)
        end
        self:message("Info", "Writing application execution code for module {b92;c15}  %s  {c7;b0}",self.opts.app)
        local tplt = self.template:gsub("${NAME}", self.opts.app or "applet")
        tplt = tplt:gsub("${APPSIZE}",applet_size)
        tplt = tplt:gsub("${REQDATA}", requires)
        tplt = tplt:gsub("${APP_CODE}", app_mod)
        ofile:write(tplt)
        if self.opts.def then ofile:write("#endif\n") end
    end
end
------------------------------------------------------------------------------
-- Execute Framework =========================================================
compile:go( arg )
-- return the application table (module)
return compile