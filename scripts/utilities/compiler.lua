-- LOG:
-- 1.1.5 : Updated with new progress bar module.
------------------------------------------------------------------------------
-- make sure that all of the used extensions are present
if ansi == nil then
    print("\x1b[34m[\x1b[91mERROR\x1b[34m]\x1b[37m: Remapping \x1b[96mansi()\x1b[37m to io.write().\n\x1b[92mPlease use eXtended Lua (\x1b[93mxLua\x1b[92m)\x1b[37m\n")  
    function ansi(s)  io.write(s) end
end
-- ---------------------------------------------------------------------------
local sep  = package.config:sub(1,1) -- extract the separator
package.path = ("..{SEP}modules{SEP}?.lua;.{SEP}modules{SEP}?.lua;"):gsub("{SEP}",sep) .. package.path
------------------------------------------------------------------------------
local app = require "app"
local progress = require "progress2"
------------------------------------------------------------------------------
local compile = app.new(false)  -- create the application framework object
------------------------------------------------------------------------------
compile.name = "Lcompile"
compile.brief = "Compile Lua source to binary chunk and/or C application file."
compile.version = "2.0.0"  -- requires xLua w/ "ansi()" function
compile.detail = [[
Lcompile is a Lua compiler that was written in Lua!  It allows for the compilation
of Lua source files into compiled binary modules and/or a C source file that can
be included in a standalone executable project.

   {c4}[{c10}USAGE{c4}]{c7}: {c15}Lcompile {c6}--quiet --def={c4}<{c5}#define{c4}> {c6}--app={c4}<{c5}object{c4}> {c6}--obj --ofile={c4}<{c5}output{c4}> {c11}...
{c7}------------------------------------------------------------------------------
   {c15}--quiet    {c7}: {c2}surppress messages on the console.
   {c15}--ofile=   {c7}: {c2}define the target C-source file.
   {c15}--def=     {c7}: {c2}Include #define flags around generate source
   {c15}--app=     {c7}: {c2}module name of the application
   {c15}--obj      {c7}: {c2}generate binary object modules for each source input
   {c15}...        {c7}: {c2}the input lua file to compile to binary.
{c7}------------------------------------------------------------------------------
Lcompile will load the input specified Lua files and compile them to a
binary chunk creating a source file containing a loader and an execution
function stubs for running the code.  Code that is "require"'d by the main
application is compiled and stored in the output C-source file.  

Note that the order of the input files on the command line are important
for the generated C-source, as they are required in the order that they are
specified.  So, make sure that interdependencies are handled by placing
files that require other files LAST in the list.

To use this tool, pass the main source to the compiler as an input file
along with the source of all the required modules (unless you want to
package the Lua with the exe).  All dependencies that are "required" are
loaded and included in the output binary chunk when specified in the build
list, otherwise they will be required from Lua and the source or Lua chunk
must be accessible on the package.path.

   Example:
   Lcompile --oflie=lcomp.c --def=LUA_COMPILE --app=compiler --obj compiler.lua ../app.lua
   Lcompile myfile.lua

------------------------------------------------------------------------------
]]
------------------------------------------------------------------------------
compile.header = [[
/**
 * ===========================================================================
 * Autogenerated application source
 * ---------------------------------------------------------------------------
 * This file was autogenerated from compiled Lua source using the Lcompile
 * Lua to C compiler.  The ouput file is intended to be compiled alongside
 * the application run-time environment that contains some extensions to
 * the base Lua language.
 * ===========================================================================
 * Built with ${VER}
 * ---------------------------------------------------------------------------
 */
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
   
#include <stdbool.h>
#include <stdint.h>   
]]
------------------------------------------------------------------------------
compile.require_template = [[
/* Required module ======================================================== */
/* MODULE : ${MODNAME} */
/* ------------------------------------------------------------------------ */
static const uint8_t ${MODNAME}_buffer[] = {
${BINDATA}
};
/* ------------------------------------------------------------------------ */
LUALIB_API int luaopen_${MODNAME}( lua_State *L )
{
    // load the chunk in bin mode and put it on the stack
    luaL_loadbufferx(L, (const char*)&${MODNAME}_buffer[0], ${SIZE}, "${MODNAME}", "b");
    /* After loading the binary chunk, we are left with a function on the stack
     * that represents the compiled code.  This pcall runs the code loaded to
     * (in the case of a require) create the stack, otherwise, only the loaded
     * code function would be stored in the `package.loaded` table.
     */
    lua_pcall(L,0,1,0); // one argument is returned... the module
    return 1;
}
/* ======================================================================== */
]]
------------------------------------------------------------------------------
compile.require_code = "   luaL_requiref(L, \"${MODNAME}\", luaopen_${MODNAME}, 1);\n   lua_pop(L,1);\n"
------------------------------------------------------------------------------
compile.template = [[
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
int app_run(lua_State *L)
{
    /* Required modules --------------------------------------------------- */
${REQDATA}
    lua_Integer top = lua_gettop(L);
    /* Run main application ----------------------------------------------- */
    // this call loads and runs the target application module
    luaopen_${NAME}(L);
    // make sure the stack is not left with stuff on it
    lua_settop(L,top);
    return 0;
}
/* ------------------------------------------------------------------------ */
/* END OF FILE ============================================================ */
]]
------------------------------------------------------------------------------
function compile:compile_source( fname )
    local chunk = string.dump( loadfile(fname,"bt"),true )

    local path = fname:split("[^/\\]+")
    local file = path[#path]   -- filename (sans path)
    local modname = file:split("[^.]+")
    if #modname > 1 then table.remove(modname,#modname) end
    modname = table.concat(modname,"_")
   
    -- new compile method for compiling lines to C
    local app = "    "
    local byte = 1
    local pb = progress.new(50,#chunk)
    pb.step = 12
    ansi("{hide}") -- turn off cursor
    while byte < #chunk do
        ansi( pb:next() .. "  {c7}Compiling file {c14}"..file.."{c7}\r")
        local ss = chunk:sub(byte,byte+12)
        if #ss > 0 then
            app = app .. ss:gsub(".",
                function(c)
                    return string.format("0x%02X, ",c:byte())
                end
                )
                -- when the line was not a complete 12-byte line,
                -- remove the trailing comma, and space.
                if #ss <12 then app = app:sub(1,#app-2) end
            byte = byte + 12
            app = app .. "\n    "
        end
    end

--[==[ Old method replaced with gsub method
    local app = "   "
    local byte = 0
    local pb = progress.new(0,#chunk)
    pb.char = {"{c7}=", "{c4}\\", "{c12}|", "{c14}/", "{c10}#" }
    pb.plain = self.plain -- propogate plain mode
    for _,v in ipairs({chunk:byte(1,#chunk)} ) do
        pb:next()  -- update progressbar position
        pb:render() -- draw it onscreen
        ansi("  compiling {c14}"..file)
        byte = byte + 1
        if byte > 12 then
            byte = 1
            app = app .. "\n   "
        end
        app = app .. string.format("0x%02X, ",v)
    end
]==]
    ansi("{c7;b0;show}  Done\n")

    -- write chunk file when asked to do so
    if self.opts.obj then
        local chunkfile = io.open(modname..".chunk","w+b")
        if chunkfile then
            chunkfile:write(chunk)
            chunkfile:close()
        else
            self:message("Error","Error writing file {c13}"..modname..".chunk")
        end
    end
    -- return the base filename, the module name, and nthe copiled chunk data
    return modname, app, #chunk
end
------------------------------------------------------------------------------
function compile:compile( file )
    local mod,data,size = self:compile_source(file)
    -- requirement was processed. add to the output file
    -- and build the require list
    local tplt = self.require_template:gsub("${MODNAME}", mod)
    tplt = tplt:gsub("${BINDATA}",data)
    tplt = tplt:gsub("${SIZE}", size)
    return mod, tplt
end
-- Framework callbacks =======================================================
------------------------------------------------------------------------------
function compile:init()
    -- tool initialization
end
------------------------------------------------------------------------------
function compile:main( ifile, ofile )

    ansi(self.name .. " Version "..self.version.."\n")
    ansi("(C) {c15}2021 {c34}E{c35}2{c214}For{c34}Life{c7}.com, CC-BY-SA-NC v4.0\n\n")

    self.opts.verbose = not self.opts.quiet
    self.plain = self.opts.plain  -- setup plain mode

    if not ifile or #ifile == 0 then
        self.opts.verbose = true
        self:message("Error","There are no input files!")
        io.write("\n\n")
        self:help()
        return false
    end

    local outfile = self.opts.ofile or "stdout"
    -- Compile the source
    -- This loads the chunks for each file, dumps the binary data and
    -- generates the loader for the module.  the loader data is stored
    -- in a big array of module names and required data
    local source_data = {}
    local requires = ""
    for _,source in ipairs(ifile) do
        local modname, code = self:compile(source)
        source_data[modname] = code
        -- assign the default application
        if not self.opts.app and self.opts.ofile then
            self:message("Warn","Setting application module to "..modname)
            self.opts.app = modname
        end
        if modname ~= self.opts.app then
            -- generate a require line for the module
            requires = requires .. self.require_code:gsub("${MODNAME}",modname)
        end
    end

    -- generate output data file
    if self.opts.ofile then
        if self.opts.def then 
            self:message("Info","Adding {c5}#ifdef{c7} conditionals for {c11}"..self.opts.def)
            ofile:write("#ifdef "..self.opts.def.."\n")
        end
        self:message("Info","Writing output file {c15}"..outfile)
        local hdr = self.header:gsub("${VER}",_VERSION)
        ofile:write(hdr)
        -- write the module loaders
        for name,code in pairs(source_data) do
            self:message("Info","Writing module {c11}"..name)
            ofile:write(code)
        end
        self:message("Info", "Writing application execution code for module {b92;c15}  "..self.opts.app.."  {c7;b0}")
        local tplt = self.template:gsub("${NAME}", self.opts.app)
        tplt = tplt:gsub("${REQDATA}", requires)
        ofile:write(tplt)
        if self.opts.def then ofile:write("#endif\n") end
    end
end
------------------------------------------------------------------------------
-- Execute Framework =========================================================
compile:go( arg )
-- return the application table (module)
return compile