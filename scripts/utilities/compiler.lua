-- LOG:
-- 1.1.5 : Updated with new progress bar module.
------------------------------------------------------------------------------
-- make sure that all of the used extensions are present
if ansi == nil then
    print("\x1b[34m[\x1b[91mERROR\x1b[34m]\x1b[37m: Remapping \x1b[96mansi()\x1b[37m to io.write().\n\x1b[92mPlease use eXtended Lua (\x1b[93mxLua\x1b[92m)\x1b[37m\n")  
    function ansi(s)  io.write(s) end
end
-- ---------------------------------------------------------------------------
local sep  = package.config:sub(1,1) -- extract the separator
package.path = ("..{SEP}modules{SEP}?.lua;.{SEP}modules{SEP}?.lua;"):gsub("{SEP}",sep) .. package.path
------------------------------------------------------------------------------
local app = require "app"
local progress = require "progress2"
------------------------------------------------------------------------------
local compile = app.new(false)  -- create the application framework object
------------------------------------------------------------------------------
compile.name = "Lcompile"
compile.brief = "Compile Lua source to binary chunk and/or C application file."
compile.version = "2.2.0"  -- requires xLua w/ "ansi()" function
compile.detail = [[
Lcompile is a Lua compiler that was written in Lua!  It allows for the compilation
of Lua source files into compiled binary modules and/or a C source file that can
be included in a standalone executable project.

   {c4}[{c10}USAGE{c4}]{c7}: {c15}Lcompile {c6}--quiet --def={c4}<{c5}#define{c4}> {c6}--app={c4}<{c5}object{c4}> {c6}--obj --ofile={c4}<{c5}output{c4}> {c11}...
{c7}------------------------------------------------------------------------------
   {c15}--quiet    {c7}: {c2}surppress messages on the console.
   {c15}--ofile=   {c7}: {c2}define the target C-source file.
   {c15}--def=     {c7}: {c2}Include #define flags around generate source
   {c15}--app=     {c7}: {c2}module name of the application
   {c15}--obj=     {c7}: {c2}generate binary object modules for each source input
   {c15}--legacy   {c7}: {c2}use Legacy file generation mode (this is SLOW)
   {c15}--fast     {c7}: {c2}Enable "fast" mode output; no newlines in data.
   {c15}...        {c7}: {c2}the input lua file to compile to binary.
{c7}------------------------------------------------------------------------------
Lcompile will load the input specified Lua files and compile them to a
binary chunk creating a source file containing a loader and an execution
function stubs for running the code.  Code that is "require"'d by the main
application is compiled and stored in the output C-source file.  

A note on object generation:
This version of lcompile enable the pre-compilation of object files into
*.chunk.c output objects.  You can use the --obj= option to set the object
directory path, or just use the --obj to specify the current directory as
the object path.

Note that the order of the input files on the command line are important
for the generated C-source, as they are loaded in the order that they are
specified.  So, make sure that interdependencies are handled by placing
files that require other files LAST in the input file list.

To use this tool, pass the main source to the compiler as an input file
along with the source of all the required modules (unless you want to
package the Lua with the exe).  All dependencies that are "required" are
loaded and included in the output binary chunk when specified in the build
list, otherwise they will be required from Lua and the source or Lua chunk
must be accessible on the package.path.

   Example:
   Lcompile --oflie=lcomp.c --def=LUA_COMPILE --app=compiler --obj compiler.lua ../app.lua
   Lcompile myfile.lua

------------------------------------------------------------------------------
]]
------------------------------------------------------------------------------
compile.header = [[
/**
 * ===========================================================================
 * Autogenerated application source
 * ---------------------------------------------------------------------------
 * This file was autogenerated from compiled Lua source using the Lcompile
 * Lua to C compiler.  The ouput file is intended to be compiled alongside
 * the application run-time environment that contains some extensions to
 * the base Lua language.
 * ===========================================================================
 * Built with ${VER}
 * ---------------------------------------------------------------------------
 */
#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"
   
#include <stdbool.h>
#include <stdint.h>   
]]
------------------------------------------------------------------------------
compile.require_template = [[
/* Required module ======================================================== */
/* MODULE : ${MODNAME} */
/* ------------------------------------------------------------------------ */
static const uint8_t ${MODNAME}_buffer[] = {
${BINDATA}
};
/* ------------------------------------------------------------------------ */
LUALIB_API int luaopen_${MODNAME}( lua_State *L )
{
    // load the chunk in bin mode and put it on the stack
    luaL_loadbufferx(L, (const char*)&${MODNAME}_buffer[0], ${SIZE}, "${MODNAME}", "b");
    /* After loading the binary chunk, we are left with a function on the stack
     * that represents the compiled code.  This pcall runs the code loaded to
     * (in the case of a require) create the stack, otherwise, only the loaded
     * code function would be stored in the `package.loaded` table.
     */
    lua_pcall(L,0,1,0); // one argument is returned... the module
    return 1;
}
/* ======================================================================== */
]]
------------------------------------------------------------------------------
compile.require_code = "   luaL_requiref(L, \"${MODNAME}\", luaopen_${MODNAME}, 1);\n   lua_pop(L,1);\n"
------------------------------------------------------------------------------
compile.template = [[
/* ------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------ */
int app_run(lua_State *L)
{
    /* Required modules --------------------------------------------------- */
${REQDATA}
    lua_Integer top = lua_gettop(L);
    /* Run main application ----------------------------------------------- */
    // this call loads and runs the target application module
    luaopen_${NAME}(L);
    // make sure the stack is not left with stuff on it
    lua_settop(L,top);
    return 0;
}
/* ------------------------------------------------------------------------ */
/* END OF FILE ============================================================ */
]]
------------------------------------------------------------------------------
function compile:get_modname( fname )
    -- split the file path name to get the file name and the pat seperate.
    local path = fname:split("[^/\\]+")
    local file = path[#path]   -- filename (sans path) is the last entry in the table
    local modname = file:split("[^%.]+") -- seperate the file name from the extenstion
    local ext = modname[#modname] -- grab the extension of the file loaded
    if #modname > 1 then table.remove(modname,#modname) end
    -- convert the table back to a string using underscores
    -- as the seperator.
    modname = table.concat(modname,"_")
    modname = modname:gsub("[%-%s]+","_") -- replace dash with underscore

    return modname, file, ext
end
------------------------------------------------------------------------------
function compile:compile_source( fname )
    -- load lua source and compile to a chunk.
    local chunk = string.dump( loadfile(fname,"bt"),true )
    -- then grab the filename and module name from the file.
    local modname, file = self:get_modname(fname)
    local app = "    "
   
    if not self.opts.legacy then
        -- new compile method for compiling lines to C
        local byte = 0
        if not self.opts.fast then
            local pb = progress.new(50,#chunk)
            pb.step = 12
            ansi("{hide}") -- turn off cursor
            while byte < #chunk do
                ansi( pb:next() .. "  {c7}Compiling file {c14}"..file.."{c7}\r")
                local ss = chunk:sub(byte+1,byte+12)
                if #ss > 0 then
                    app = app .. ss:gsub(".",
                        function(c)
                            return string.format("0x%02X, ",c:byte())
                        end
                        )
                    byte = byte + 12
                    app = app .. "\n    "
                end
            end
        else
            -- generate "fast" mode data output (all on one line)
            -- that will just burst generate the output with no
            -- newlines.  this is generally most useful for huge
            -- lua source that takes a while to compile.
            app = app .. chunk:gsub(".",
                function(c)
                    return string.format("0x%02X, ",c:byte())
                end
            )
        end
    else
        -- Legacy method replaced with gsub method
        local byte = 0
        local pb = progress.new(0,#chunk)
        pb.char = {"{c7}=", "{c4}\\", "{c12}|", "{c14}/", "{c10}#" }
        pb.plain = self.plain -- propogate plain mode
        for _,v in ipairs({chunk:byte(1,#chunk)} ) do
            pb:next()  -- update progressbar position
            pb:render() -- draw it onscreen
            ansi("  compiling {c14}"..file)
            byte = byte + 1
            if byte > 12 then
                byte = 1
                app = app .. "\n   "
            end
            app = app .. string.format("0x%02X, ",v)
        end
    end
    ansi("{c7;b0;show}\n  Done\n")

    -- return the base filename, the module name, and nthe copiled chunk data
    return modname, app, #chunk
end
------------------------------------------------------------------------------
function compile:compile( file )
    local mod,fname,ftype = self:get_modname(file)
    local tplt = ""
    local data = ""
    local size = 0
    if ftype:lower() ~= "lua" then
        -- load a pre-compiled object
        mod = mod:gsub("_chunk","") -- remove chunk portion of name
        self:message("info","Loading precompiled module {c6}%s{c7}.",mod)
        local fil = io.open(file,"r")
        if not fil then
            self:message("error","Could not opern pre-compiled module {c9}%s{c7}.",fname)
            return nil,nil
        end
        tplt = fil:read("a") -- load the precompiled module
        fil:close()
    else
        mod,data,size = self:compile_source(file)
        -- requirement was processed. add to the output file
        -- and build the require list
        tplt = self.require_template:gsub("${MODNAME}", mod)
        tplt = tplt:gsub("${BINDATA}",data)
        tplt = tplt:gsub("${SIZE}", size)
    
        if self.opts.obj then
            local obj = ""
            if type(self.opts.obj) == "string" then
                obj = string.format("%s%s%s.chunk.c",self.opts.obj, sep, mod)
            else
                obj = string.format("%s.chunk.c",mod)
            end
            local chunkfile = io.open(obj,"w+")
            if chunkfile then
                chunkfile:write(tplt)
                chunkfile:close()
            else
                self:message("Error","Error writing module {c13}%s{c7} to file {c11}%s{c7}.", mod, obj)
            end
        end
    end
    return mod, tplt
end
-- Framework callbacks =======================================================
------------------------------------------------------------------------------
function compile:init()
    -- tool initialization and setting of default options and switches
end
------------------------------------------------------------------------------
function compile:main( ifile, ofile )

    ansi(self.name .. " Version "..self.version.."\n")
    ansi("(C) {c15}2021 {c34}E{c35}2{c214}For{c34}Life{c7}.com, CC-BY-SA-NC v4.0\n\n")

    self.opts.verbose = not self.opts.quiet
    self.plain = self.opts.plain  -- setup plain mode

    if not ifile or #ifile == 0 then
        self.opts.verbose = true
        self:message("Error","There are no input files!")
        io.write("\n\n")
        self:help()
        return false
    end

    local outfile = self.opts.ofile or "stdout"
    -- Compile the source
    -- This loads the chunks for each file, dumps the binary data and
    -- generates the loader for the module.  the loader data is stored
    -- in a big array of module names and required data
    local source_data = {}
    local requires = ""
    for _,source in ipairs(ifile) do
        local modname, code = self:compile(source)
        if modname == nil then 
            self:message("error","Errors detected during compilation.")
            return false, "compile error"
        end
        source_data[modname] = code
        -- assign the default application
        if not self.opts.app and self.opts.ofile then
            self:message("Warn","Setting application module to "..modname)
            self.opts.app = modname
        end
        if modname ~= self.opts.app then
            -- generate a require line for the module
            requires = requires .. self.require_code:gsub("${MODNAME}",modname)
        end
    end

    -- generate output data file
    if self.opts.ofile then
        if self.opts.def then 
            self:message("Info","Adding {c5}#ifdef{c7} conditionals for {c11}"..self.opts.def)
            ofile:write("#ifdef "..self.opts.def.."\n")
        end
        self:message("Info","Writing output file {c15}%s",outfile)
        local hdr = self.header:gsub("${VER}",_VERSION)
        ofile:write(hdr)
        -- write the module loaders
        for name,code in pairs(source_data) do
            self:message("Info","Writing module {c11}%s",name)
            ofile:write(code)
        end
        self:message("Info", "Writing application execution code for module {b92;c15}  %s  {c7;b0}",self.opts.app)
        local tplt = self.template:gsub("${NAME}", self.opts.app)
        tplt = tplt:gsub("${REQDATA}", requires)
        ofile:write(tplt)
        if self.opts.def then ofile:write("#endif\n") end
    end
end
------------------------------------------------------------------------------
-- Execute Framework =========================================================
compile:go( arg )
-- return the application table (module)
return compile